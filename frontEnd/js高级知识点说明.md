#### 一 闭包: 能够读取其他函数内部变量的函数

严格来说，闭包需要满足三个条件：

【1】访问所在作用域；

【2】函数嵌套；

【3】在所在作用域外被调用

#### 二 作用域：

      作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。**

**ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域**。

在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：

- 最外层函数 和在最外层函数外面定义的变量拥有全局作用域
- 所有末定义直接赋值的变量自动声明为拥有全局作用域
- 所有 window 对象的属性拥有全局作用域

全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起**命名冲突**。

函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

**作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行**。

**块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域**。在块语句中定义的变量将保留在它们已经存在的作用域中。

块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：

1. 在一个函数内部
2. 在一个代码块（由一对花括号包裹）内部

let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：

- 声明变量不会提升到代码块顶部

- 禁止重复声明

- 循环中的绑定块作用域的妙用

  开发者可能最希望实现 for 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，

#### 三 作用域链：

1. 首先认识一下什么叫做 **自由变量** 。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找

2. 什么是作用域链？如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。

3. 关于自由变量的取值，上文提到要到父作用域中取；

   要到创建 fn 函数的那个作用域中取，**无论 fn 函数将在哪里调用**。先从本函数作用域取值，然后从创建函数的那个作用域取值，一层层往上找

4. 作用域与执行上下文

   预编译：1. 创建AO对象， 2. 找形参和变量声明，将变量和形参名作为AO属性名，值为undefined， 3. 将实参值和形参统一，4. 在函数体里面找函数声明，值赋予函数体

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190821095952190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODQyNzg2,size_16,color_FFFFFF,t_70)

   JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段，这两个阶段所做的事并不一样：

   **解释阶段：**（语法（义）分析）

   - 词法分析
   - 语法分析
   - 作用域规则确定

   **执行阶段：**

   - 创建执行上下文
   - 执行函数代码
   - 垃圾回收

   JavaScript 解释阶段便会确定作用域规则，因此**作用域在函数定义时就已经确定**了，而不是在函数调用时确定，但是**执行上下文是函数执行之前创建的**。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

   作用域和执行上下文之间最大的区别是：

   **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。

   **同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值**。

   **作用域是啥？**

   > 作用域是根据名称查找变量的一套规则。负责收集并维护有所有声明的标识符（变量）组成的一系列查询，并实施一套严格规则，确定当前执行的代码对这些标识符的访问权限。

   在预编译的基础上

           **[[scope]]:**每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供javascript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了执行期上下文的集合。
           **作用域链：**[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。
           **运行期上下文:**当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行期上下文被销毁。
           **查找变量：**从作用域链的顶端依次向下查找



#### 四 原型链：

什么是原型链？

                原型链中就是实例对象和原型对象之间的连接，每个函数都有一个prototype的属性，这个prototype属性就是我们的原型对象，我们拿这个函数通过new构造函数创建出来的实例对象，这个实例对象自己会有一个指针(_*proto*_)指向他的构造函数的原型对象！这样构造函数和实例对象之间就通过( _*proto*_ )连接在一起形成了一条链子。

原型链的特点：

1. 所有函数都存在原型对象属性prototype，并且所有函数的默认原型都是Object的实例。

2. 每个继承父函数的实例对象都包含一个内部的属性__proto__。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的__proto__属性为再上一层函数。在此过程中形成了原型链。

3.  就近原则，优先找最近的，沿着原型链继续往上找，直到Object,

4. 引用类型，原型链上的值是引用类型，修改值会全部都改了

5. 可以通过 isPrototypeOf 方法来确定对象之间是否存在这种关系。如果[[Prototype]]指向调用isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回true。

   `Person.prototype**.**isPrototypeOf(person1);  //true`

6. hasOwnProperty方法可以检测一个属性是存在于实例中，还是存在于原型中（从Object继承来的），只在给定属性存在于对象实例中时，才会返回true

7. 单独使用in操作符时，无论属性存在于实例中还是原型中，只要能访问到给定属性都返回true。

   `'name' in person1; //true`

原型属性：

                prototype构造函数的原型，constructor：指向改原型原本的构造函数

__proto__和prototype的区别:

                __proto__：是实例对象指向原型对象的指针，隐式原型，是每个对象都会有的一个属性。
                prototype：是构造函数的原型对象，显式原型，只有函数才会有。

**原型链的特殊情况的几条总结：**

1. Object并不是原型链顶层，Object.prototype才是原型链的顶层，有：Object.prototype.__proto__ == null
2.  所有函数都是Function的实例(包括Function)，有：Function.prototype == Function.__proto__
3.  所有对象都是Object的实例(包括原型对象)，有:Function.prototype.__proto__ ==Object.prototype



![img](https://ask.qcloudimg.com/http-save/yehe-2919294/8r2zc851at.png?imageView2/2/w/1620)



#### 五 继承（原型，组合，寄生，构造函数）

原型链继承

核心：将父类的实例作为子类的原型

```elm
SubType.prototype = new SuperType()
// 所有涉及到原型链继承的继承方式都要修改子类构造函数的指向，否则子类实例的构造函数会指向SuperType。
SubType.prototype.constructor = SubType;
```

优点：父类方法可以复用
缺点：

- 父类的引用属性会被所有子类实例共享
- 子类构建实例时不能向父类传递参数

构造函数继承

核心：将父类构造函数的内容复制给了子类的构造函数。这是所有继承中唯一一个不涉及到prototype的继承。



防抖
节流
react react-dom react-recompiler 源码
vue源码+核心
nodejs
webpack plugin loader



小程序

http熟悉那些方面呢？
200-504

cors 6
http1.0 1.1 2.0
jwt
cookie

垃圾回收机制


babel